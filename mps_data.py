from __future__ import annotations
"""
Bridge – MPS Data Layer
Loads provider data from JSON files generated by pipeline.py
"""

import json
import os
import random
from datetime import datetime, timedelta

DATA_DIR = os.path.dirname(__file__)


def _load_provider_data():
    """Scan for *_data.json files and merge into unified data structures."""
    all_mps = []
    all_providers = {}
    all_platforms = set()
    all_styles = set()
    all_historical = {}
    all_benchmarks = {"trailing": [], "calendar": []}
    all_cost_tables = []
    all_current_aa = []
    all_risk_return = []

    for filename in sorted(os.listdir(DATA_DIR)):
        if filename.endswith("_data.json"):
            path = os.path.join(DATA_DIR, filename)
            with open(path, "r") as f:
                data = json.load(f)

            all_mps.extend(data.get("mps", []))
            for name, prov in data.get("providers", {}).items():
                all_providers[name] = prov
            all_platforms.update(data.get("platforms", []))
            all_styles.update(data.get("styles", []))
            for key, val in data.get("historical", {}).items():
                all_historical[key] = val
            all_benchmarks["trailing"].extend(data.get("benchmarks", {}).get("trailing", []))
            all_benchmarks["calendar"].extend(data.get("benchmarks", {}).get("calendar", []))
            all_cost_tables.extend(data.get("cost_table", []))
            all_current_aa.extend(data.get("current_asset_allocation", []))
            all_risk_return.extend(data.get("risk_return", []))

            print(f"  Loaded {filename}: {len(data.get('mps', []))} portfolios")

    return {
        "mps": all_mps,
        "providers": all_providers,
        "platforms": sorted(all_platforms),
        "styles": sorted(all_styles),
        "historical": all_historical,
        "benchmarks": all_benchmarks,
        "cost_table": all_cost_tables,
        "current_asset_allocation": all_current_aa,
        "risk_return": all_risk_return,
    }


print("Bridge: Loading provider data...")
_DATA = _load_provider_data()

MPS_UNIVERSE = _DATA["mps"]
PROVIDERS = _DATA["providers"]
PLATFORMS = _DATA["platforms"]
INVESTMENT_STYLES = _DATA["styles"]
HISTORICAL = _DATA["historical"]
BENCHMARKS = _DATA["benchmarks"]
COST_TABLE = _DATA["cost_table"]
CURRENT_AA = _DATA["current_asset_allocation"]
RISK_RETURN = _DATA["risk_return"]

print(f"Bridge: {len(MPS_UNIVERSE)} portfolios, {len(PROVIDERS)} providers, {len(PLATFORMS)} platforms")


# ─── Query functions ───────────────────────────────────────────────────

def get_all_mps() -> list[dict]:
    return MPS_UNIVERSE

def get_providers() -> dict:
    return PROVIDERS

def get_provider(provider_name: str) -> dict | None:
    return PROVIDERS.get(provider_name)

def get_mps_by_provider(provider_name: str) -> list[dict]:
    return [m for m in MPS_UNIVERSE if m["provider"] == provider_name]

def get_mps_by_id(mps_id: str) -> dict | None:
    return next((m for m in MPS_UNIVERSE if m["id"] == mps_id), None)

def get_platforms() -> list[str]:
    return PLATFORMS

def get_investment_styles() -> list[str]:
    return INVESTMENT_STYLES

def get_historical(key: str = None) -> dict:
    if key:
        return HISTORICAL.get(key, {})
    return HISTORICAL

def get_benchmarks() -> dict:
    return BENCHMARKS

def get_cost_table() -> list[dict]:
    return COST_TABLE

def get_current_asset_allocation() -> list[dict]:
    return CURRENT_AA

def get_risk_return() -> list[dict]:
    return RISK_RETURN

def get_performance_history(mps_id: str, months: int = 36) -> list[dict]:
    """Generate performance history from return data.
    In production, replace with actual NAV/price data."""
    mps = get_mps_by_id(mps_id)
    if not mps:
        return []

    annual_return = mps.get("return_1yr") or 8.0
    monthly_return = annual_return / 12 / 100
    history = []
    value = 100.0
    random.seed(hash(mps_id))

    end_date = datetime.now()
    for i in range(months, 0, -1):
        date = end_date - timedelta(days=i * 30)
        noise = random.gauss(0, 0.015)
        value *= (1 + monthly_return + noise)
        history.append({
            "date": date.strftime("%Y-%m-%d"),
            "value": round(value, 2),
        })
    return history

def filter_mps(
    risk_min: int = 1, risk_max: int = 10,
    platforms: list[str] | None = None,
    providers: list[str] | None = None,
    styles: list[str] | None = None,
    ethical_only: bool = False,
    decumulation: bool = False,
    time_horizon: str | None = None,
    ocf_max: float | None = None,
) -> list[dict]:
    results = []
    for m in MPS_UNIVERSE:
        if m["risk_rating"] < risk_min or m["risk_rating"] > risk_max:
            continue
        if platforms and not any(p in m.get("platforms", []) for p in platforms):
            continue
        if providers and m["provider"] not in providers:
            continue
        if ethical_only and not m.get("ethical", False):
            continue
        if decumulation and not m.get("decumulation_suitable", False):
            continue
        if time_horizon and time_horizon not in m.get("time_horizons", []):
            continue
        if ocf_max is not None and m.get("ocf", 0) > ocf_max:
            continue
        results.append(m)
    return results
